{"all_cnt": 3, "all_request_sequence": [{"method": "POST", "api": "/elements/length/groupBy/boundary/groupBy/tag", "url": "https://api.ohsome.org/v1/elements/length/groupBy/boundary/groupBy/tag", "headers": {"Content-Type": "application/x-www-form-urlencoded"}, "params": {}, "payload": {"bboxes": "areaBox1:8.67,49.41,8.95,49.49", "bcircles": "areaCircle1:8.8,49.43,500", "bpolys": "{\"type\":\"FeatureCollection\",\"features\":[{\"type\":\"Feature\",\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[8.75,49.40],[8.85,49.40],[8.85,49.50],[8.75,49.50],[8.75,49.40]]]},\"properties\":{\"id\":\"poly1\"}}]}", "filter": "type=way and (highway=* or building=*)", "groupByKey": "highway,building", "format": "json"}, "payload_type": "application/x-www-form-urlencoded", "request_data": "method='POST' api='/elements/length/groupBy/boundary/groupBy/tag' params={} payload={'bboxes': 'areaBox1:8.67,49.41,8.95,49.49', 'bcircles': 'areaCircle1:8.8,49.43,500', 'bpolys': '{\"type\":\"FeatureCollection\",\"features\":[{\"type\":\"Feature\",\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[8.75,49.40],[8.85,49.40],[8.85,49.50],[8.75,49.50],[8.75,49.40]]]},\"properties\":{\"id\":\"poly1\"}}]}', 'filter': 'type=way and (highway=* or building=*)', 'groupByKey': 'highway,building', 'format': 'json'}", "response_code": 400, "response_data": "{\"timestamp\":\"2025-09-17T09:09:46.112154923\",\"status\":400,\"message\":\"You need to give one groupByKey parameter, if you want to use groupBy/tag.\",\"requestUrl\":\"https://api.ohsome.org/v1/elements/length/groupBy/boundary/groupBy/tag\"}"}, {"method": "POST", "api": "/elements/length/groupBy/boundary/groupBy/tag", "url": "https://api.ohsome.org/v1/elements/length/groupBy/boundary/groupBy/tag", "headers": {"Content-Type": "application/x-www-form-urlencoded"}, "params": {}, "payload": {"bboxes": "areaBox1:8.67,49.41,8.95,49.49", "bcircles": "areaCircle1:8.8,49.43,500", "bpolys": "{\"type\":\"FeatureCollection\",\"features\":[{\"type\":\"Feature\",\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[8.75,49.40],[8.85,49.40],[8.85,49.50],[8.75,49.50],[8.75,49.40]]]},\"properties\":{\"id\":\"poly1\"}}]}", "filter": "type=way and highway=*", "groupByKey": "highway", "format": "json"}, "payload_type": "application/x-www-form-urlencoded", "request_data": "method='POST' api='/elements/length/groupBy/boundary/groupBy/tag' params={} payload={'bboxes': 'areaBox1:8.67,49.41,8.95,49.49', 'bcircles': 'areaCircle1:8.8,49.43,500', 'bpolys': '{\"type\":\"FeatureCollection\",\"features\":[{\"type\":\"Feature\",\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[8.75,49.40],[8.85,49.40],[8.85,49.50],[8.75,49.50],[8.75,49.40]]]},\"properties\":{\"id\":\"poly1\"}}]}', 'filter': 'type=way and highway=*', 'groupByKey': 'highway', 'format': 'json'}", "response_code": 400, "response_data": "{\"timestamp\":\"2025-09-17T09:10:01.520567128\",\"status\":400,\"message\":\"Your provided boundary parameter (bboxes, bcircles, or bpolys) does not fit its format, or you defined more than one boundary parameter.\",\"requestUrl\":\"https://api.ohsome.org/v1/elements/length/groupBy/boundary/groupBy/tag\"}"}, {"method": "POST", "api": "/elements/length/groupBy/boundary/groupBy/tag", "url": "https://api.ohsome.org/v1/elements/length/groupBy/boundary/groupBy/tag", "headers": {"Content-Type": "application/x-www-form-urlencoded"}, "params": {}, "payload": {"bboxes": "areaBox1:8.67,49.41,8.95,49.49|areaBox2:8.60,49.38,8.70,49.45", "filter": "type=way and (highway=primary or building=house)", "groupByKey": "highway", "format": "json"}, "payload_type": "application/x-www-form-urlencoded", "request_data": "method='POST' api='/elements/length/groupBy/boundary/groupBy/tag' params={} payload={'bboxes': 'areaBox1:8.67,49.41,8.95,49.49|areaBox2:8.60,49.38,8.70,49.45', 'filter': 'type=way and (highway=primary or building=house)', 'groupByKey': 'highway', 'format': 'json'}", "response_code": 200, "response_data": "{\"attribution\":{\"url\":\"https://ohsome.org/copyrights\",\"text\":\"\\u00a9 OpenStreetMap contributors\"},\"apiVersion\":\"1.10.4\",\"groupByResult\":[]}"}], "right_results": [{"request_info": "POST /elements/length/groupBy/boundary/groupBy/tag with multiple bounding boxes, filter='type=way and (highway=primary or building=house)', groupByKey='highway', format='json'", "oracle": "A successful 200 OK response containing a JSON object with length metrics grouped by each specified boundary type and tag combination, accurately reflecting aggregated lengths without merges or overlaps causing data misrepresentation.", "judge_reason": "The response status is 200 OK, which aligns with the expectation of success. However, the 'groupByResult' array is empty, indicating no length metrics grouped by boundary and tag were returned. This might be due to no matching data for the specified filter in the boundaries or absence of OSM elements for those tags. Thus, while structurally correct and a valid JSON, functionally it does not fulfill the test objective of providing aggregated length results. The response partially aligns as valid but misses the core data expected.", "response": "HTTP 200 OK with empty 'groupByResult' array"}], "wrong_results": [{"request_info": "POST /elements/length/groupBy/boundary/groupBy/tag with boundaries (bbox, circle, polygon), filter='type=way and (highway=* or building=*)', groupByKey='highway,building', format='json'", "oracle": "A successful 200 OK response containing a JSON object with length metrics grouped by each specified boundary type and tag combination, accurately reflecting aggregated lengths without merges or overlaps causing data misrepresentation.", "judge_reason": "The actual response is HTTP 400 Bad Request with a clear error message stating that only one groupByKey parameter is allowed for the groupBy/tag endpoint. Although multiple boundary types and multiple tags were correctly provided, the API rejected the request due to how the groupByKey was specified as 'highway,building'. This deviates significantly from the expected behavior which anticipated successful handling of multiple groupBy keys. This is a fundamental mismatch affecting the entire functionality of simultaneous grouping by multiple tags.", "response": "HTTP 400 with message: You need to give one groupByKey parameter, if you want to use groupBy/tag."}, {"request_info": "POST /elements/length/groupBy/boundary/groupBy/tag with bboxes, bcircles, and bpolys simultaneously specified, filter='type=way and highway=*', groupByKey='highway', format='json'", "oracle": "A successful 200 OK response containing a JSON object with length metrics grouped by each specified boundary type and tag combination, accurately reflecting aggregated lengths without merges or overlaps causing data misrepresentation.", "judge_reason": "The actual response is a 400 Bad Request indicating the boundary parameters do not fit the format or more than one was provided. The request contained bboxes, bcircles, and bpolys simultaneously, violating the requirement that only one boundary parameter should be defined in a request. This contradicts the expectation that the API supports multiple boundary types combined in one call and is a significant deviation impacting the core test of multi-boundary grouping.", "response": "HTTP 400 Bad Request with message indicating boundary parameter format issue or multiple boundaries specified."}], "test_scenario_response_message": "1. **Title:** Count Length of OSM Elements Grouped by Boundary and Tag with Complex Multi-Boundary and Multi-Tag Inputs  \n   - **API Endpoint:** POST /elements/length/groupBy/boundary/groupBy/tag  \n   - **Description:**  \n     Begin by submitting a request containing multiple spatial boundaries of different types (e.g., bounding box, circle, and polygon) combined in the payload. Alongside, provide multiple OSM tags (e.g., highway=*, building=*) to group the length aggregation by tag. This request tests if the endpoint can correctly handle simultaneous grouping by both boundary and tag for complex spatial inputs.  \n   - **Expected Response:**  \n     A successful 200 OK response containing a JSON object with length metrics grouped by each specified boundary type and tag combination. The response should accurately reflect aggregated lengths corresponding to each spatial grouping and tag set. No merges or overlaps in group keys that could cause data misrepresentation.\n\n2. **Title:** Validate Consistency of Length Aggregation After Altering Tag Set  \n   - **API Endpoint:** POST /elements/length/groupBy/boundary/groupBy/tag  \n   - **Description:**  \n     Immediately after step 1, send a modified request changing the tag parameter by removing one tag and adding a new unrelated tag (e.g., remove building, add natural=water). Keep the same boundaries as in the initial request. This step verifies that the result set updates correctly reflecting only the newly requested tag and excludes the old tag, showing distinct and correctly scoped aggregations.  \n   - **Expected Response:**  \n     200 OK with length aggregations grouped only by the current set of tags and original boundaries. The response must not contain data from the previous tags nor mixing between tags. Length values corresponding to the removed tags should be absent.\n\n3. **Title:** Re-send Initial Request to Verify Idempotency and Cache Consistency  \n   - **API Endpoint:** POST /elements/length/groupBy/boundary/groupBy/tag  \n   - **Description:**  \n     Re-submit the original request from step 1 exactly as before to confirm that the API responds consistently. This tests idempotency and state consistency under repeated identical requests, ensuring caching or state management does not skew results over time or after changes in request parameters in step 2.  \n   - **Expected Response:**  \n     200 OK response with length results matching precisely those in step 1 without extra, missing, or altered data, demonstrating stable, repeatable aggregation outcomes.\n\n4. **Title:** Submit Malformed Request with Mixed or Conflicting Boundary Geometry Data  \n   - **API Endpoint:** POST /elements/length/groupBy/boundary/groupBy/tag  \n   - **Description:**  \n     Send a request payload where the spatial boundaries include invalid geometric definitions (e.g., polygon coordinates that self-intersect or improperly closed polygons) combined with an empty or missing tag parameter. This tests boundary input validation and error handling robustness, as well as mandatory parameter enforcement for tags.  \n   - **Expected Response:**  \n     HTTP 400 Bad Request with a clear error message specifying invalid boundary geometry and/or missing required tag parameters. The system should not process corrupted boundaries or incomplete grouping attributes.\n\n5. **Title:** Test System Behavior Under Large and Overlapping Boundaries with Multiple Tags  \n   - **API Endpoint:** POST /elements/length/groupBy/boundary/groupBy/tag  \n   - **Description:**  \n     Furnish a request with a large number of complex, overlapping boundaries (e.g., several polygons that partially intersect) combined with several tags. This tests if the API handles overlapping spatial queries properly without double counting or incorrect aggregation. The step also examines server performance and stability under computationally heavy input.  \n   - **Expected Response:**  \n     A 200 OK response with accurate length aggregations where overlapping boundaries are handled correctly (e.g., no duplicated length sums in intersecting regions unless expected). The data must logically separate overlaps in aggregation groups by boundary and tag. The response time should be within acceptable limits showing system endurance.\n\n6. **Title:** Edge Case - Submit Empty Boundary and Tag Arrays  \n   - **API Endpoint:** POST /elements/length/groupBy/boundary/groupBy/tag  \n   - **Description:**  \n     Send an empty or null array for both boundaries and tags to test API validation rules on mandatory grouping parameters. This assesses endpoint defenses against insufficient input and response as per contract.  \n   - **Expected Response:**  \n     HTTP 400 Bad Request with error details indicating the necessity of at least one boundary and one tag parameter to perform the grouping operation.\n\n7. **Title:** Cross-validation of Length Aggregations After Single Boundary and Single Tag Query  \n   - **API Endpoint:** POST /elements/length/groupBy/boundary/groupBy/tag  \n   - **Description:**  \n     Query again with a minimal valid payload: a single simple boundary (e.g., one bounding box) and a single tag (e.g., highway=primary). This verification step compares the length output against aggregated results from prior steps that included this boundary and tag to ensure partial results sum accurately within larger aggregated sets and no data loss occurs.  \n   - **Expected Response:**  \n     200 OK with length values consistent as a subset of corresponding aggregation entries from previous multi-boundary/multi-tag requests. Data consistency between partial and full aggregations should be evident.\n\n**Summary:**  \nThis scenario thoroughly validates the POST /elements/length/groupBy/boundary/groupBy/tag endpoint by exercising complex and varied combinations of spatial boundaries and OSM tags. It checks aggregation correctness under multi-boundary and multi-tag conditions, verifies idempotency and caching behavior, insists on strict input validation including malformed spatial data handling, and confirms error responses for insufficient inputs. Large overlapping boundary testing and partial vs. full aggregation consistency assessments help expose defects in spatial grouping logic, parameter management, concurrency effects, and server stability under stress.", "usage": {"total_tokens": 133042, "total_cost": 0.0589888}, "unique_endpoints": {"200": ["POST /elements/length"], "300": [], "400": ["POST /elements/length"], "500": 0}, "total_true_result": 1, "total_false_result": 2}