{"all_cnt": 3, "all_request_sequence": [{"method": "POST", "api": "/elements/length/density/groupBy/boundary/groupBy/tag", "url": "https://api.ohsome.org/v1/elements/length/density/groupBy/boundary/groupBy/tag", "headers": {"Content-Type": "application/x-www-form-urlencoded"}, "params": {}, "payload": {"bpolys": "{\"type\":\"FeatureCollection\",\"features\":[{\"type\":\"Feature\",\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[8.6810,49.4160],[8.6950,49.4160],[8.6950,49.4300],[8.6810,49.4300],[8.6810,49.4160]]]},\"properties\":{\"id\":\"poly1\"}}]}", "filter": "type=way and (highway=primary or highway=secondary)", "groupByKey": "highway", "groupByValues": "primary,secondary", "format": "json", "showMetadata": "true"}, "payload_type": "application/x-www-form-urlencoded", "request_data": "method='POST' api='/elements/length/density/groupBy/boundary/groupBy/tag' params={} payload={'bpolys': '{\"type\":\"FeatureCollection\",\"features\":[{\"type\":\"Feature\",\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[8.6810,49.4160],[8.6950,49.4160],[8.6950,49.4300],[8.6810,49.4300],[8.6810,49.4160]]]},\"properties\":{\"id\":\"poly1\"}}]}', 'filter': 'type=way and (highway=primary or highway=secondary)', 'groupByKey': 'highway', 'groupByValues': 'primary,secondary', 'format': 'json', 'showMetadata': 'true'}", "response_code": 200, "response_data": "{\"attribution\":{\"url\":\"https://ohsome.org/copyrights\",\"text\":\"\\u00a9 OpenStreetMap contributors\"},\"apiVersion\":\"1.10.4\",\"metadata\":{\"executionTime\":9211,\"description\":\"Density of selected items (length of items in meters divided by the area in square kilometers), aggregated on the boundary and on the tag.\"},\"groupByResult\":[{\"groupByObject\":[\"poly1\",\"highway=secondary\"],\"result\":[{\"timestamp\":\"2025-08-20T11:00:00Z\",\"value\":0.0}]},{\"groupByObject\":[\"poly1\",\"highway=primary\"],\"result\":[{\"timestamp\":\"2025-08-20T11:00:00Z\",\"value\":0.0}]}]}"}, {"method": "POST", "api": "/elements/length/density/groupBy/boundary/groupBy/tag", "url": "https://api.ohsome.org/v1/elements/length/density/groupBy/boundary/groupBy/tag", "headers": {"Content-Type": "application/x-www-form-urlencoded"}, "params": {}, "payload": {"bpolys": "{\"type\":\"FeatureCollection\",\"features\":[{\"type\":\"Feature\",\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[8.6750,49.4100],[8.7000,49.4100],[8.7000,49.4400],[8.6750,49.4400],[8.6750,49.4100]]]},\"properties\":{\"id\":\"updatedPoly1\"}}]}", "filter": "type=way and (highway=primary or highway=secondary)", "groupByKey": "highway", "groupByValues": "primary,secondary", "format": "json", "showMetadata": "true"}, "payload_type": "application/x-www-form-urlencoded", "request_data": "method='POST' api='/elements/length/density/groupBy/boundary/groupBy/tag' params={} payload={'bpolys': '{\"type\":\"FeatureCollection\",\"features\":[{\"type\":\"Feature\",\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[8.6750,49.4100],[8.7000,49.4100],[8.7000,49.4400],[8.6750,49.4400],[8.6750,49.4100]]]},\"properties\":{\"id\":\"updatedPoly1\"}}]}', 'filter': 'type=way and (highway=primary or highway=secondary)', 'groupByKey': 'highway', 'groupByValues': 'primary,secondary', 'format': 'json', 'showMetadata': 'true'}", "response_code": 200, "response_data": "{\"attribution\":{\"url\":\"https://ohsome.org/copyrights\",\"text\":\"\\u00a9 OpenStreetMap contributors\"},\"apiVersion\":\"1.10.4\",\"metadata\":{\"executionTime\":8794,\"description\":\"Density of selected items (length of items in meters divided by the area in square kilometers), aggregated on the boundary and on the tag.\"},\"groupByResult\":[{\"groupByObject\":[\"updatedPoly1\",\"highway=secondary\"],\"result\":[{\"timestamp\":\"2025-08-20T11:00:00Z\",\"value\":0.0}]},{\"groupByObject\":[\"updatedPoly1\",\"highway=primary\"],\"result\":[{\"timestamp\":\"2025-08-20T11:00:00Z\",\"value\":0.0}]}]}"}, {"method": "POST", "api": "/elements/length/density/groupBy/boundary/groupBy/tag", "url": "https://api.ohsome.org/v1/elements/length/density/groupBy/boundary/groupBy/tag", "headers": {"Content-Type": "application/x-www-form-urlencoded"}, "params": {}, "payload": {"bpolys": "[{\"type\":\"Feature\",\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[8.6780,49.4162],[8.6825,49.4185],[8.6850,49.4145],[8.6780,49.4162]]]}},{\"type\":\"Feature\",\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[8.7000,49.4200],[8.7050,49.4220],[8.7070,49.4190],[8.7000,49.4200]]]}}]", "filter": "type=way and (highway=primary or highway=residential)", "groupByKey": "highway", "groupByValues": "primary,residential", "format": "json", "showMetadata": "true"}, "payload_type": "application/x-www-form-urlencoded", "request_data": "method='POST' api='/elements/length/density/groupBy/boundary/groupBy/tag' params={} payload={'bpolys': '[{\"type\":\"Feature\",\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[8.6780,49.4162],[8.6825,49.4185],[8.6850,49.4145],[8.6780,49.4162]]]}},{\"type\":\"Feature\",\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[8.7000,49.4200],[8.7050,49.4220],[8.7070,49.4190],[8.7000,49.4200]]]}}]', 'filter': 'type=way and (highway=primary or highway=residential)', 'groupByKey': 'highway', 'groupByValues': 'primary,residential', 'format': 'json', 'showMetadata': 'true'}", "response_code": 400, "response_data": "{\"timestamp\":\"2025-09-17T09:21:45.471344839\",\"status\":400,\"message\":\"Error in processing the boundary parameter. Please remember to follow the format, where you separate every coordinate with a comma, each boundary object with a pipe-sign and add optional custom ids to every first coordinate with a colon.\",\"requestUrl\":\"https://api.ohsome.org/v1/elements/length/density/groupBy/boundary/groupBy/tag\"}"}], "right_results": [{"request_info": "POST /elements/length/density/groupBy/boundary/groupBy/tag with malformed bpolys parameter", "oracle": "HTTP 400 Bad Request with an informative error message explaining the invalid boundary geometry input. The API should not process or return any aggregation results.", "judge_reason": "The response has HTTP status 400 Bad Request, which matches the expected error code for malformed boundary geometry inputs. The error message clearly explains how the boundary parameter should be formatted, demonstrating robust validation and user guidance. No aggregation data was returned, correctly indicating the request was rejected due to invalid input. This response aligns well with the expected behavior for input validation failures.", "response": "HTTP 400 Bad Request with error message detailing expected boundary parameter format."}], "wrong_results": [{"request_info": "POST /elements/length/density/groupBy/boundary/groupBy/tag with valid polygon boundary 'poly1' and tags 'highway=primary, highway=secondary'", "oracle": "HTTP 200 OK with a JSON body containing density values grouped by the specified boundary and tags. The response should include meaningful, non-zero density values reflecting realistic data distribution.", "judge_reason": "The response code is 200 OK, which matches the expected successful status. The response includes density results grouped by the specified boundary and tags, demonstrating correct grouping behavior. However, the density values are zero for both tags, which contradicts the expectation of meaningful, non-zero densities reflecting realistic data. This is a significant deviation because the zero density values imply no presence of the tagged OSM elements, which is unlikely for typical data and may indicate issues with data availability or filtering. Despite the correct response structure, the zero values constitute a failure to meet the expected meaningful density criteria.", "response": "HTTP 200 OK with density values zero for all tags in the groupByResult."}, {"request_info": "POST /elements/length/density/groupBy/boundary/groupBy/tag with updated polygon boundary 'updatedPoly1' and tags 'highway=primary, highway=secondary'", "oracle": "HTTP 200 OK with updated density values that reflect the larger boundary area. Density values should logically be equal or higher than the initial query for overlapping tags and boundaries, ensuring consistency in aggregation.", "judge_reason": "The response code is HTTP 200 OK, consistent with expectations. The response's grouping correctly reflects the updated boundary polygon and tags. However, the density values for both tags remain zero, showing no increase or change compared to the initial query. This contradicts the expected behavior where densities should logically be equal or higher for the larger boundary area. The zero values imply an issue with data retrieval or aggregation that affects meaningful density reporting. This is a significant deviation affecting the functional expectations of the API for this test case.", "response": "HTTP 200 OK with zero density values for all tags in the groupByResult."}], "test_scenario_response_message": "1. **Title:** Initial Density Query with Boundary and Tag Groupings\n   - **API Endpoint:** POST /elements/length/density/groupBy/boundary/groupBy/tag\n   - **Description:** Send a request with a single well-defined geographic boundary polygon and multiple valid OSM tags (e.g., highway, waterway). This step aims to retrieve the density of OSM elements grouped by the provided boundary and tags.\n   - **Expected Response:** HTTP 200 OK with a JSON body containing density values grouped by the specified boundary and tags. The response should include meaningful, non-zero density values reflecting realistic data distribution.\n\n2. **Title:** Repeat Query with Slightly Modified Boundary Polygon\n   - **API Endpoint:** POST /elements/length/density/groupBy/boundary/groupBy/tag\n   - **Description:** Modify the initial boundary polygon by slightly expanding it to include adjacent areas while keeping the same set of tags. This tests if the API correctly recalculates densities for the new combined area groupings and updates data accordingly without stale cache results.\n   - **Expected Response:** HTTP 200 OK with updated density values that reflect the larger boundary area. Density values should logically be equal or higher than the initial query for overlapping tags and boundaries, ensuring consistency in aggregation.\n\n3. **Title:** Query with Invalid Boundary Geometry\n   - **API Endpoint:** POST /elements/length/density/groupBy/boundary/groupBy/tag\n   - **Description:** Submit a request where the boundary polygon is malformed (e.g., self-intersecting polygon or missing coordinates), but the tags provided are valid. This tests robustness and input validation of boundary geometries.\n   - **Expected Response:** HTTP 400 Bad Request with an informative error message explaining the invalid boundary geometry input. The API should not process or return any aggregation results.\n\n4. **Title:** Query Using No Tags Provided (Empty Tags Parameter)\n   - **API Endpoint:** POST /elements/length/density/groupBy/boundary/groupBy/tag\n   - **Description:** Send a request with a valid boundary polygon but omit or provide an empty list for the tags parameter. This step checks how the API handles missing tags in a multi-grouping context.\n   - **Expected Response:** Expected behavior could be either HTTP 400 Bad Request indicating required tags missing or HTTP 200 OK returning aggregated densities grouped only by boundary. This step checks for consistent, documented behavior and appropriate error or fallback processing.\n\n5. **Title:** Complex Query with Multiple Boundaries and Multiple Tags\n   - **API Endpoint:** POST /elements/length/density/groupBy/boundary/groupBy/tag\n   - **Description:** Submit a request with multiple valid geographic boundaries (e.g., multiple polygons representing different cities or regions) along with several tags. This tests the API\u2019s handling of multiple boundary inputs simultaneously and combined grouping logic.\n   - **Expected Response:** HTTP 200 OK returning density aggregations separately grouped by each boundary and tag. The results should be consistent with individual queries of the same boundaries and tags run separately. No data overlaps or conflicts between boundaries should appear.\n\n6. **Title:** Sequential Consistency Check by Comparing Individual vs Bulk Requests\n   - **API Endpoint:** POST /elements/length/density/groupBy/boundary/groupBy/tag\n   - **Description:** Run two separate requests for each boundary individually with the same tags used in step 5, then compare the sum of returned densities to the values aggregated in the bulk multi-boundary request. This validates aggregation consistency.\n   - **Expected Response:** The sum of densities from individual boundary queries should approximate or equal the corresponding grouped densities in the bulk request without unexpected variance, ensuring internal consistency.\n\n7. **Title:** Idempotency and State Persistence Test by Repeating Identical Requests\n   - **API Endpoint:** POST /elements/length/density/groupBy/boundary/groupBy/tag\n   - **Description:** Repeat a previously successful complex multi-boundary and tag query multiple times to verify consistent responses without side effects or state changes such as unexpected fluctuations in density values.\n   - **Expected Response:** HTTP 200 OK responses with identical density aggregation results on each repeated request, confirming idempotency and stable internal state handling.\n\n8. **Title:** Stress Test with Large-Scale Boundary and Tag Inputs\n   - **API Endpoint:** POST /elements/length/density/groupBy/boundary/groupBy/tag\n   - **Description:** Submit a request containing a very large and complex boundary polygon (e.g., a country-level polygon), combined with a large set of diverse tags (e.g., 20+ tags). This tests the endpoint\u2019s performance, scalability, and correct processing of heavy input loads.\n   - **Expected Response:** HTTP 200 OK ideally within acceptable performance thresholds. Response must include correct densities grouped by boundary and tag without timeouts, incomplete data, or server errors.\n\n9. **Title:** Request with Mixed Valid and Invalid Tags\n   - **API Endpoint:** POST /elements/length/density/groupBy/boundary/groupBy/tag\n   - **Description:** Provide a valid boundary alongside a mix of valid tags and invalid/non-existent tags to verify input validation and partial failure handling.\n   - **Expected Response:** HTTP 200 OK response that excludes invalid tags from the aggregation results or returns a structured error detailing unrecognized tags without failing the whole request. Density data should correspond only to valid tags.\n\n10. **Title:** Cleanup Scenario with Empty Boundary and Tag Payload\n    - **API Endpoint:** POST /elements/length/density/groupBy/boundary/groupBy/tag\n    - **Description:** Send a request with empty or null boundary and tag parameters to check API behavior on effectively no input data.\n    - **Expected Response:** Expected HTTP 400 Bad Request with clear messaging about missing required boundary and tag parameters or HTTP 200 OK with empty aggregation results, depending on API spec. This tests handling of empty or default states.\n\n---\n\n**Summary:**\n\nThis comprehensive scenario tests the POST /elements/length/density/groupBy/boundary/groupBy/tag endpoint for a wide variety of realistic use cases. Beginning with simple valid queries, it progresses to altered boundaries, invalid inputs, multi-boundary groups, idempotency, large-scale stress, mixed validity tags, and empty parameters. This workflow is designed to reveal defects related to input validation, aggregation correctness, state consistency, error handling, performance under load, and API robustness with multiple grouping dependencies. It also verifies logical consistency between individual and grouped aggregations, ensuring reliable density calculations across complex spatial data inputs.", "usage": {"total_tokens": 119694, "total_cost": 0.05372160000000001}, "unique_endpoints": {"200": ["POST /elements/length"], "300": [], "400": ["POST /elements/length"], "500": 0}, "total_true_result": 1, "total_false_result": 2}